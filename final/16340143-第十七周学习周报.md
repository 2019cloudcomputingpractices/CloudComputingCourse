## 本周具体工作计划

完成以下内容：

- FTP服务器的优化

## 本周主要工作内容

### i. 已经完成工作

#### 1.ftp服务器的优化

**1.1 提高服务器accept连接的速度**

上周的代码中accept和创建新的处理线程是放在同一个循环中，如下所示

```c++
void Server::Start() {
    int sock = CreateSocket(port_);
    Print("Server listen on %d...\n", port_);
    for (;;) {
        int newsock = AcceptConnection(sock);
        std::thread t(&Server::NewConnection, this, newsock);
        t.detach();
    }
}
```

由于创建线程的速度远远比accept慢的多（尤其是在并发连接较多时），accept和创建线程的同步执行会大大降低accept的速度。因此我们将accept的任务和创建线程的任务在两个不同的线程中完成。主线程负责accept任务，并把新的连接存放在缓冲区中，另一个线程（这里不妨成为worker线程）负责创建子线程处理连接的任务，worker线程从缓冲区中获取新的连接来创建新的线程，即主线程和worker线程之间是生产者消费者的关系。



改进后的代码如下

```c++
void _worker(Server* srv) {
    Print("Worker ready...\n");
    int sock = srv->GetConn();
    for (;;) {
        while(sock < 0) {
            sock = srv->GetConn();
        }
        std::thread t(&Server::NewConnection, srv, sock);
        t.detach();
        sock = -1;
    }
}

void Server::Start() {
    std::thread t(&_worker, this);
    t.detach();
    int sock = CreateSocket(port_);
    Print("Server listen on %d...\n", port_);
    for (;;) {
        int newsock = AcceptConnection(sock);
        this->PutConn(newsock);
    }
}
```





**1.2 减少数据端口的冲突**

一开始为了设计的方便，在被动模式下创建数据连接时，端口的分配我们采用随机分配的方式。如下所示

```c++
void GenPort(Port *port)
{
  srand(time(NULL));
  port->p1 = 128 + (rand() % 64);
  port->p2 = rand() % 0xff;
}
```

每个处理连接的线程各自随机生成一个端口号用于建立数据连接，在分配端口比较频繁的时候发生冲突的概率会比较大，这个时候就不得不尝试重新分配新的端口，直到获取到一个没被占用的端口。

为了减少这种冲突的可能性，我们将在Server类实现了端口分配函数，数据端口由Server实例统一分配（新的端口号每次加1，并限制在某个范围内），这样能够大大降低服务器内部数据端口的冲突次数。



### ii. 未完成工作

FTP服务器的性能测试

### iii. 问题与困难

分析服务器性能和调试比较困难，需要借助多种工具，如抓包分析，gprof 性能分析等。

## 下周工作计划

FTP服务器的性能测试

## 建议与意见

无