# 本周具体工作计划
+ Python Flask Web框架学习
+ 研读云晫系统源代码，整理代码结构

# 本周主要工作内容
+ 开发一个基于Flask的Web应用demo
+ 在报告中列出代码的组织结构
+ 根据Flask的框架，思考该项目是怎么启动的，开启一个云桌面调用了哪些接口，哪些包，把启动流程写入报告中。

## 已完成工作
### flask框架应用demo部分
这部分因为只是一个demo，所以就以学习为主，写了一个登录的系统，代码在task5/flask-demo下，首先目录结构如下：
![](https://raw.githubusercontent.com/2019cloudcomputingpractices/CloudComputingCourse/16340147-%E5%88%98%E6%81%92%E4%BC%9F/task5/image/1.png)

这里template文件夹主要就包括了一些模版文件，供渲染使用，而static就包括了一些静态文件，在本项目中就是css文件，要创建一个flask应用很简单，直接安装flask后app = Flask(__name__)就可以创建一个应用了，然后就可以用app.route这样的注解，给应用添加各种各样的路由，在flask中似乎并没有单独的router设计，router和controller耦合较为严重，然后在注解中可以用methods参数指定接收哪些方法，在函数中可以用request.method访问具体的方法是GET还是POST等，其他就是一些sqlite的使用了，不是本次实验的重点，所以就不说了，要run起一个flask应用，首先要在命令行中定义FLASK_APP这个环境变量（这个设计我也不是太喜欢，感觉这种操作对于项目启动来说就很不友好）在powershell中就是$env:FLASK_APP = "demo.py"，然后flask run就可以了，首先我们进入注册界面，并且注册一个用户：
![](https://raw.githubusercontent.com/2019cloudcomputingpractices/CloudComputingCourse/16340147-%E5%88%98%E6%81%92%E4%BC%9F/task5/image/2.png)

注册用户成功（这里界面偷了下懒）：
![](https://raw.githubusercontent.com/2019cloudcomputingpractices/CloudComputingCourse/16340147-%E5%88%98%E6%81%92%E4%BC%9F/task5/image/3.png)

然后进入登录界面输入刚才注册的用户邮箱密码：
![](https://raw.githubusercontent.com/2019cloudcomputingpractices/CloudComputingCourse/16340147-%E5%88%98%E6%81%92%E4%BC%9F/task5/image/4.png)

登录成功:
![](https://raw.githubusercontent.com/2019cloudcomputingpractices/CloudComputingCourse/16340147-%E5%88%98%E6%81%92%E4%BC%9F/task5/image/5.png)

输入错误密码后登录失败：
![](https://raw.githubusercontent.com/2019cloudcomputingpractices/CloudComputingCourse/16340147-%E5%88%98%E6%81%92%E4%BC%9F/task5/image/6.png)

可以看到基本登录注册功能已经完成，运行正常

### 整理代码结构部分
+ doc文件夹有一些项目本身的文档，使用了sphinx文档工具来进行编写
+ infras文件夹中包括了一些包括mysql,rabbitmq等的配置信息
+ src文件夹为源代码
	- etc文件夹也是包括了一些mysql,openstack,spice的配置信息
	- gateway主要是网关相关代码，里面的gateway_config.py是从config.ini中读信息供其他程序使用，然后gateway_server负责建立socket，并且建立连接，提供获取虚拟机信息的接口等
	- 在license文件夹中
		+ 首先app文件夹包括了主体代码部分
			- account文件夹负责用户相关操作，比如注册登录，修改用户信息等，同时也有权限的相关认证代码，这部分就采用了flask框架，可以看到有很多与用户操作相关的路由
			- instance文件夹负责实例相关操作，比如创建删除实例，更新实例信息，查询实例等等
			key文件夹包括了一些公钥和私钥，供验证的时候使用
			- main文件夹则是对于主界面的一些跳转代码
			- 以上account,instance,main都是基于flask框架构建的，但是这些代码都是router和controller层（这里router和controller没有分开，看的还是比较蛋疼，是我写的话应该会分开，这也是flask本身框架的问题我觉得），并没有包含model层
			- static和templates就是flask里面很常规的静态文件和模版文件的存储位置，供上面说的controller进行渲染
			此外还有email.py来发送邮件
			- models.py里面包括了在controller中用到的一些类，比如Permission,User,Instance等
			- randompsw.py用来生成随机字符串，似乎用的不是很多，基本可以不管
		+ migrations里面包含了进行迁移的代码，这部分主要是用到了alembic和sqlalchemy，这两个库都是和数据库迁移相关的，所以代码都不是自己实现的，写的较为简单
		+ tests里面什么都没有，很明显是偷懒了
		+ tools里面的代码就是简单的在python里面调用了其他的程序，基本也是进行一些数据库迁移，更新，部署等操作
		+  manage.py里面包含了一些初始化的代码，可以看到里面run起来了一个flask的Manager，还有一些部署的操作
		+ 此外config.py就是进行获取一些配置信息，其他文件也是一些配置文件
	- 在phoenix文件夹中
		+ cloud文件夹就代码来说基本就没干什么事，就是调用了一些phoenix.cloud.utils里面的函数，然后函数名都不带改的直接包装一下，其主要就是和openstack打交道，包含了增删改查实例，设置安全组，设置浮动ip，设置路由之类的openstack里面基本所有的操作
		+ common文件夹里面包含了一些工具类和函数，比如文件锁，ping函数，代理，单例，时间处理等
		+ db文件夹主要用phoenix和sqlalchemy，进行了一些有关于floating_ip的相关操作，sqlalchemy是python中一个成熟的orm库
		+ security文件夹我并没有看出有什么作用，感觉是没写
		+ config.py似乎实现了一些option的类，剩下的也是实现了Config类进行一些配置之类的
		+ 除此之外的py文件似乎就真的没有什么作用了，一堆的pass或者就是NotImplementedError，感觉也是没写
	- scheduler中就针对linux和windows两个不同的平台实现了后台调度程序，用来管理进程，不过windows好像没写全
	- test文件夹就是对以上的各个文件夹中的代码写了一些测试模块
	- web文件夹是整个程序的主体部分，其利用flask框架，实现了我们可以访问的所有的api，不过似乎和之前license文件夹中用户的那部分有点重复，这部分没怎么搞懂。这部分主要就是利用了flask的蓝图，先在整体的__init__.py中先定义app，然后再定义各个模块蓝图，这些模块的实现就在web文件夹中的各个子文件夹中，同样每个子文件夹也有一个__init__.py，用来获取蓝图，然后在各个文件中就实现了各种路由，部分文件作为model
	- 剩下的代码就都是一些model类，比如定义User,Flavor,Desktop等，供各个蓝图模块使用

整个项目的启动我觉得是基于src/web文件夹的，在src/web/__init__.py下创建了整个web应用的主体app，然后给app定义了很多个蓝图，再把蓝图交给各个模块去实现，在flask框架有关代码中用的比较多的模块主要有phoenix和sqlalchemy，phoenix主要是提供了一些和openstack打交道的接口，比如对server、flavor、hypervisor的增删改查等，而sqlalchemy则是一个很成熟的python orm框架，其把关系数据库的表结构映射到对象上，以便于操作。以开启一个云桌面为例，我们首先要通过路由定位到相关的controller代码，然后controller代码会调用model，也就是src/web/app/desktop/utils.py中的创建虚拟机代码，这里可以看到一只利用了一个db对象，而这个db实际上是一个HackedSQLAlchemy的实例，而HackedSQLAlchemy又是继承了SQLAlchemy，也就是实际上还是用了SQLAlchemy这个orm库来进行数据库的操作，操作完毕后执行celery_tasks.run_desktoptask函数，我们继续追溯可以看到执行了sub_tasks.append(build_desktop.subtask((), {'task_id':task_id}))函数，sub_tasks只是一个任务的数组，推测应该是后面进行任务调度要使用，所以我们关注build_desktop.subtask函数，从celery_tasks.py中可以看到这个函数里面初始化了一个Desktop对象，然后后面对vm进行配置后，执行了instance = compute.create_server()函数，这也是真正创建虚拟机的操作，之前的Desktop只是一个交互的对象而已，然后我们看到compute实际上是由phoenix.cloud引入的，这也证实了本工程确实是利用phoenix.cloud进行和openstack的交互的，我们再看Desktop对象本身，其内部定义的各种函数实际上也是大量使用了phoenix.cloud.compute包进行openstack操作，以及sqlalchemy来进行数据库的管理。



## 未完成工作
部分云桌面的代码还不是很看得懂，只能看懂大概是在干什么，但是对细节还是有很多疑惑
## 问题与困难
在制作flask-demo的时候主要就是遇到了css文件一开始不知道放哪的问题，我一开始以为应该是可以直接用相对路径的，但是我看了flask的终端输出发现，他根本就没有按照我的想法在相对路径中找，后面查了下发现这些静态文件不能放在模版文件夹中，而要放在一个额外的static文件夹中，在引用的时候就直接href="{{ url_for('static', filename='demo.css') }}"即可。还有就是看代码结构的时候，也只能根据函数名看个大概，整体每个模块具体哪个作用，模块之间是怎么交互的还是有很多疑惑
## 建议与意见
个人觉得flask有点垃圾，我个人做项目的话肯定不会用这种框架