## 本周具体工作计划

学习以下内容：

- 研读《Flask Web开发：基于Python的Web应用开发》电子书，学习flask框架
- 根据书中的叙述，尝试在自己的开发环境中，开发一个基于Flask的Web应用demo

## 本周主要工作内容

### i. 已经完成工作

#### 1. 学习Flask

**1.1 Flask框架简介**

Flask是一个基于Python的Web框架，它的设计目的是提高Web开发所需要的**最小功能子集**。Flask与别的框架（尤其是采用其他编程语言的框架）的不同之处在于：它没有绑定诸如数据库查询或者表单处理等功能库，以及它们所组成的整个生态系统。Flask具备良好的扩展性，支持所有的关系型数据库，也支持非关系型数据库。你可以自主选择程序的组件（就像node.js后端开发也有很多第三方组件可选），如果找不到合适的，还可以自己开发。

第一次接触使用Flask框架编写的后端代码觉得很有Python风格，函数装饰器及Python本身的动态性被充分利用，同时最好先熟悉Python自定义模块和包的编写和引用的规则，开发时通常需要将代码划分成不同模块。

初次学习Flask框架，主要先从一个简单的Flask后端开始，然后逐渐了解并使用Flask框架相关的一些常用组件。

**1.2 快速入门**

运行一个简单的flask后端需要先安装flask，可用如下命令安装

```bash
# （如需要）可先激活或创建本地的虚拟环境
$ pip install flask
```

然后编写hello.py

```python
# 目录结构
# 根目录：
# hello.py
# 404.html（内容随意，比如<h1>404</h1>）
# 500.html（内容随意，比如<h1>500</h1>）

# hello.py内容
from flask import Flask, render_template
# 传入__name__，Flask用这个参数决定程序的根目录，以便于以后能够找到相对于程序根目录的资源文件位置
app = Flask(__name__)

# 视图函数，返回响应内容
# app.route装饰器用于将函数注册到相应的路由路径
@app.route('/')
def index():
    return '<h1>Hello World!</h1>'

# 错误处理
@app.errorhandler(404)
def page_not_found(e):
    print('404 handled')
    # render_template可以将html模板渲染后输出作为响应，可传入变量用于渲染，flask使用的是Jinja2模板引擎
    return render_template('404.html'), 404

# 错误处理
@app.errorhandler(500)
def internal_server_error(e):
    return render_template('500.html'), 500


# 动态路由可以这么添加，/user/hello之类的url都会与该路由匹配
@app.route('/user/<name>')
def user(name):
    return '<h1>Hello, %s!</h1>' % name

if __name__ == '__main__':
    # 默认运行在http://localhost:5000
    app.run(debug=True)
```



执行python hello.py即可在浏览器打开http://localhost:5000看到"Hello World!"，打开http://localhost:5000/user/yourname即可看到"Hello yourname!"，上面演示了如何定义路由及相应的处理函数，但奇怪的是处理函数的参数列表中没有req和res对象，这一点和其他语言的web框架比较不同。

事实上，Flask框架是这样获得请求上下文及其他相关上下文的。

```python
from flask import Flask
# 从flask中引入上下文
from flask import current_app, g, request, session，make_response
# 上下文介绍
# current_app为程序上下文，表示当前激活程序的程序实例
# g为程序上下文，处理请求时用作临时存储的对象。每次请求都会重设这个变量
# request，请求上下文，即请求对象，封装了客户端发出的HTTP请求中的内容
# session，请求上下文，即用户会话，用于存储请求之前需要“记住”的值/状态的字典
# 以上的上下文变量都是线程安全的，每个处理请求的线程都能安全地访问这些上下文

# 传入__name__，Flask用这个参数决定程序的根目录，以便于以后能够找到相对于程序根目录的资源文件位置
app = Flask(__name__)

# 视图函数，返回响应内容
# app.route装饰器用于将函数注册到相应的路由路径
@app.route('/')
def index():
    # 使用request对象能获取客户端发出的HTTP请求中的内容
    user_agent = request.headers.get('User-Agent')
    # make_response可以用于生成响应结果并返回
    res = make_response('<h1>Hello World!</h1>')
    res.set_cookie('user-agent',user_agent or 'none')
    return res


if __name__ == '__main__':
    # 默认运行在http://localhost:5000
    app.run(debug=True)
```

学习到这里我们已经基本能够写出简单的Flask后端了，接下来进一步了解常用的组件以及如何将他们和app实例联系起来。



**1.3 Blueprint**

这个组件类似于一个router，可将功能相近的api或页面放在同一个Blueprint实例中，然后再将Blueprint实例注册到app上即可完成路由映射的功能。该组件内置在flask中，示例代码如下：

```python
# 目录结构
# 根目录：
# hello.py
# /templates
#	index.html
# 	404.html（内容随意，比如<h1>404</h1>）
# 	500.html（内容随意，比如<h1>500</h1>）
# /static

# hello.py内容
from flask import Flask, render_template
from flask_login import current_user
from flask import Blueprint

# 定义一个Blueprint实例
main_blueprint = Blueprint(
    'main',
    __name__,
    template_folder='/templates',
    static_folder='/static',
)

@main_blueprint.route('/')
def index():
    return render_template('index.html', current_user=current_user)


@main_blueprint.app_errorhandler(404)
def page_not_found(e):
    return render_template('404.html'), 404


@main_blueprint.app_errorhandler(500)
def internal_server_error(e):
    return render_template('500.html'), 500

app = Flask(__name__)
# 将上面的Blueprint实例注册到app实例上，这样才能使main_blueprint实例的路由生效
app.register_blueprint(main_blueprint)

if __name__ == '__main__':
    # 默认运行在http://localhost:5000
    app.run(debug=True)
```



**1.4 Jinja2模板引擎**

这里主要简单介绍一下Jinja2模板引擎的语法。Jinja2模板引擎也和现在前端常用的模板语法有相似的功能，例如变量绑定，列表渲染，条件渲染，模板继承等。

以下用一个简单的例子展示一下Jinja2的语法：

```html
{# 这是注释 #}
{# 这份文件是base.html #}
{# extends表示这份模板继承了bootstrap/base.html的内容 #}
{# bootstrap/base.html由Bootstrap组件提供，需要我们在程序中引入，下一部分会介绍 #}
{% extends "bootstrap/base.html" %}

{# 声明一个块，块名为navbar，该块内容将会替换父模板中navbar的内容 #}
{% block navbar %}
    <div class="navbar navbar-inverse" role="navigation">
        <div class="container">
            <div class="navbar-header">
                <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
                    <span class="sr-only">Toggle navigation</span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                </button>
                <a class="navbar-brand" href="{{ url_for('main.index') }}">Flask Demo</a>
            </div>
            <div class="navbar-collapse collapse">
                <ul class="nav navbar-nav">
                    <li><a href="{{ url_for('main.index') }}">Home</a></li>
                </ul>
                <ul class="nav navbar-nav navbar-right">
                    {% if current_user.is_authenticated %}
                    <li><a href="{{ url_for('auth.logout') }}">Log Out</a></li>
                    {% else %}
                    <li><a href="{{ url_for('auth.login') }}">Log In</a></li>
                    {% endif %}
                </ul>
            </div>
        </div>
    </div>
{% endblock %}
{# 块结束标志 #}

{% block content %}
<div class="container">
    {% for message in get_flashed_messages() %}
    <div class="alert alert-warning">
        <button type="button" class="close" data-dismiss="alert">&times;</button>
        {{ message }}
    </div>
    {% endfor %}

    {% block page_content %}{% endblock %}
</div>
{% endblock %}

{% block scripts %}
{{ super() }}
{% endblock %}
```



```html
{# 这是注释 #}
{# 这份文件是继承了上面的base.html的index.html #}
{% extends "base.html" %}

{% block title %}Index Page{% endblock %}

{% block page_content %}
<div class="page-header">
    <h1>Hello, {% if current_user.is_authenticated %}{{ current_user.username }}{% else %}Stranger{% endif %}!</h1>
</div>
{% endblock %}
```



**1.5 Bootstrap**

Bootstrap组件提供了一些基本的模板（可在模板文件中继承），引入方式如下：

```python
# 组件安装方法：
# pip install flask-bootstrap
# 目录结构
# 根目录：
# hello.py
# /templates
#	index.html
# 	404.html（内容随意，比如<h1>404</h1>）
# 	500.html（内容随意，比如<h1>500</h1>）
# /static

# hello.py内容
from flask import Flask
# 引入Bootstrap组件，然后还需要在下面的代码中注册该组件
from flask_bootstrap import Bootstrap


# 实例化组件
bootstrap = Bootstrap()

app = Flask(__name__)
# 通过init_app方法将组件与app实例关联起来，这样组件便能获得app实例的信息并为app实例提供组件包括的功能，大多组件都可以使用该方式初始化
bootstrap.init_app(app)

if __name__ == '__main__':
    # 默认运行在http://localhost:5000
    app.run(debug=True)
```



**1.6 SQLAlchemy**

这是一个ORM组件，通过它可以将python中的对象与数据库表中的数据映射起来，通过操作python中的对象即可完成对数据库的操作。

```python
# 组件安装方法：
# pip install flask-sqlalchemy
# 目录结构
# 根目录：
# main.py
# models.py
# /templates
#	index.html
# 	404.html（内容随意，比如<h1>404</h1>）
# 	500.html（内容随意，比如<h1>500</h1>）
# /static

# main.py内容
from flask import Flask
# 引入SQLAlchemy组件，然后还需要在下面的代码中注册该组件
from flask_sqlalchemy import SQLAlchemy

# 实例化组件
db = SQLAlchemy()

app = Flask(__name__)
# 通过init_app方法将组件与app实例关联起来，这样组件便能获得app实例的信息并为app实例提供组件包括的功能
# 组件所需要的配置信息会从app获取，如数据库访问地址，密码等，所以需要对app进行配置，后面的介绍会提及
db.init_app(app)

if __name__ == '__main__':
    # 默认运行在http://localhost:5000
    app.run(debug=True)
```



```python
# models.py内容
from main import db, login_manager
from werkzeug.security import generate_password_hash, check_password_hash
from itsdangerous import TimedJSONWebSignatureSerializer as Serializer
from flask import current_app
from flask_login import UserMixin


class Role(db.Model):
    __tablename__ = 'roles'
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(64), unique=True)
    users = db.relationship('User', backref='role', lazy='dynamic')

    def __repr__(self):
        return '<Role %r>' % self.name


class User(UserMixin, db.Model):
    __tablename__ = 'users'
    id = db.Column(db.Integer, primary_key=True)
    email = db.Column(db.String(64), unique=True, index=True)
    username = db.Column(db.String(64), unique=True, index=True)
    role_id = db.Column(db.Integer, db.ForeignKey('roles.id'))
    password_hash = db.Column(db.String(128))
    confirmed = db.Column(db.Boolean, default=False)

    @property
    def password(self):
        raise AttributeError('password is not a readable attribute')

    @password.setter
    def password(self, password):
        self.password_hash = generate_password_hash(password)

    def verify_password(self, password):
        return check_password_hash(self.password_hash, password)

    def generate_confirmation_token(self, expiration=3600):
        s = Serializer(current_app.config['SECRET_KEY'], expiration)
        return s.dumps({'confirm': self.id}).decode('utf-8')

    def confirm(self, token):
        s = Serializer(current_app.config['SECRET_KEY'])
        try:
            data = s.loads(token.encode('utf-8'))
        except UnicodeEncodeError:
            return False
        else:
            return False
        if data.get('confirm') != self.id:
            return False
        self.confirmed = True
        db.session.add(self)
        return True

    def __repr__(self):
        return '<User %r>' % self.username


@login_manager.user_loader
def load_user(user_id):
    return User.query.get(int(user_id))

```



**1.7 配置app实例的常用方法**

```python
# 组件安装方法：
# pip install flask-sqlalchemy
# 目录结构
# 根目录：
# main.py
# config.py
# /templates
#	index.html
# 	404.html（内容随意，比如<h1>404</h1>）
# 	500.html（内容随意，比如<h1>500</h1>）
# /static

# main.py内容
from flask import Flask
from config import config

app = Flask(__name__)
# 导入配置信息
config_name = 'development'
app.config.from_object(config[config_name])
# 初始化，可自定义该函数
config[config_name].init_app(app)

if __name__ == '__main__':
    # 默认运行在http://localhost:5000
    app.run(debug=True)
```



```python
# config.py内容
import os
basedir = os.path.abspath(os.path.dirname(__file__))


class Config:
    SECRET_KEY = os.environ.get('SECRET_KEY') or 'hard to guess string'
    MAIL_SERVER = os.environ.get('MAIL_SERVER', 'smtp.googlemail.com')
    MAIL_PORT = int(os.environ.get('MAIL_PORT', '587'))
    MAIL_USE_TLS = os.environ.get('MAIL_USE_TLS', 'true').lower() in \
        ['true', 'on', '1']
    MAIL_USERNAME = os.environ.get('MAIL_USERNAME')
    MAIL_PASSWORD = os.environ.get('MAIL_PASSWORD')
    FLASKY_MAIL_SUBJECT_PREFIX = '[Flasky]'
    FLASKY_MAIL_SENDER = 'Flasky Admin <flasky@example.com>'
    FLASKY_ADMIN = os.environ.get('FLASKY_ADMIN')
    SQLALCHEMY_TRACK_MODIFICATIONS = False

    @staticmethod
    def init_app(app):
        pass


class DevelopmentConfig(Config):
    DEBUG = True
    SQLALCHEMY_DATABASE_URI = os.environ.get('DEV_DATABASE_URL') or \
        'sqlite:///' + os.path.join(basedir, 'data-dev.sqlite')


class TestingConfig(Config):
    TESTING = True
    SQLALCHEMY_DATABASE_URI = os.environ.get('TEST_DATABASE_URL') or \
        'sqlite://'


class ProductionConfig(Config):
    SQLALCHEMY_DATABASE_URI = os.environ.get('DATABASE_URL') or \
        'sqlite:///' + os.path.join(basedir, 'data.sqlite')


config = {
    'development': DevelopmentConfig,
    'testing': TestingConfig,
    'production': ProductionConfig,

    'default': DevelopmentConfig
}
```





#### 2. Flask Demo

在第一部分已经介绍了Flask的基本使用以及一些常用的组件，现在可以综合运用上面的知识写一个简单的包含登录和注册功能的web app。

代码地址：[Flask Demo](/flask_demo)

首页（登录前）：

![index-before-login](images/index-before-login.png?raw=true)

登录页面：

![login](images/login.png?raw=true)

注册页面：

![register](images/register.png?raw=true)



首页（登录后）：

![index-after-login](images/index-after-login.png?raw=true)



### ii. 未完成工作

无

### iii. 问题与困难

初次阅读基于Flask写的代码觉得还是和基于js的框架的代码有比较明显的不同，但也依然还是有不少可以类比的地方。

## 下周工作计划

开始准备期末考核任务

## 建议与意见

无