# 大项目week1周报

## 本周具体工作计划

- 学习nodejs的TCP socket编程
- 实现一个服务端和客户端的demo，使得服务端和客户端可以通过TCP socket进行通信

## 本周主要工作内容

### 已经完成工作

- 学习nodejs的TCP socket编程
- 实现一个服务端和客户端的demo，使得服务端和客户端可以通过TCP socket进行通信

## 未完成工作

无

## 问题与困难

无

## 下周工作计划

- 学习FTP协议，了解FTP的交互过程
- 实现一个简易版的FTP应用

------

## nodejs的TCP socket编程

Node是一个面向网络而生的平台，它具有事件驱动、无阻塞、单线程等特性，具备良好的可伸缩性，使得它十分轻量，适合在分布式网络中扮演各种各样的角色。同时Node提供的API十分贴合网络，适合用它基础的API构建灵活的网络服务。

Node提供了net、dgram、http、https这4个模块，分别用于处理TCP、UDP、HTTP、HTTPS，适用于服务端和客户端。

由于大项目决定使用TCP socket构建一个FTP服务器，因此这里着重对net模块的学习。

### 1. net.Server 类

#### 事件：

通过``net.createServer()``可返回一个net.Server实例。

``net.Server``继承自``EventEmitter``，实现了以下事件:

- listening：在调用``server.listen()``绑定端口后触发，简洁写法为``server.listen(port, listeningListener)``，第二个参数作为listening事件的监听器。
- connection：每个客户端套接字连接到客户端时触发，简洁写法为通过``net.createServer()``最后一个参数作为connection事件的监听器，传入事件监听器的参数是一个``net.Socket``的实例对象。
- close：当server关闭的时候触发. 注意,如果有连接存在, 直到所有的连接结束才会触发这个事件。
- error：当错误出现的时候触发，如果不监听error事件，服务器将会抛出异常。传入事件监听器的参数是一个Error对象。

#### 方法：

- server.address()：返回一个有 `port`, `family`, 和 `address` 属性: `{ port: 12346, family: 'IPv4', address: '127.0.0.1' }`的对象。

- server.close([callback])：停止 server接受建立新的connections并保持已经存在的connections。当所有的connections关闭同时server响应 'close'事件的时候,server将会最终关闭. 一旦'close'发生将会调用可选的回调函数. 

- server.getConnections(callback)：异步获取服务器的当前并发连接数。当 socket 被传递给子进程时工作。回调函数的两个参数是 err 和 count。

- ``server.listen([port[, host[, backlog]]][, callback])``：启动一个TCP服务监听输入的`port`和`host`。如果port省略或是0，系统会随意分配一个在'listening'事件触发后能被server.address().port检索的无用端口。如果host省略，如果IPv6可用，服务器将会接收基于unspecified IPv6 address (::)的连接，否则接收基于unspecified IPv4 address (0.0.0.0)的连接。

### 2. net.Socket 类

此类是 TCP 套接字的抽象， net.Socket 也是双工流，因此它既可读也可写。

net.Socket 可以由用户创建并直接用于与服务器交互。 例如，它由 ``net.createConnection()`` 返回，因此用户可以使用它与服务器通信。

它也可以由 Node.js 创建，并在收到连接时传给用户。 例如，它被传给 net.Server 上触发的 'connection' 事件的监听器，因此用户可以使用它与客户端进行交互。

``net.Socket``继承自``EventEmitter``，实现了以下事件:

#### 事件：

- data：当接收到数据的时触发该事件。data 参数是一个 Buffer 或 String。数据编码由 ``socket.setEncoding()`` 设置。当一端调用``write()``发生数据时，另一端会触发data事件。

- end：当 socket 的另一端发送一个 FIN 包的时候触发，从而结束 socket 的可读端。

- connect：当一个 socket 连接成功建立的时候触发该事件。``net.createConnection(options[, connectListener])``如果有``connectListener``，将被添加为返回 socket 上的 'connect' 事件上的监听器。

- drain：当写入缓冲区变为空时触发。可以用来做上传节流。

- close：一旦 socket 完全关闭就发出该事件。参数 had_error 是 boolean 类型，表明 socket 被关闭是否取决于传输错误。事件监听器的参数为had_error <boolean>， 如果 socket 有传输错误就为 true。

- error：当错误发生时触发。'close' 事件也会紧接着该事件被触发。

- timeout：当 socket 超时的时候触发。该事件只是用来通知 socket 已经闲置。用户必须手动关闭。

#### 方法：

- socket.address()：返回操作系统报告的 socket 的地址、地址族和端口。返回的对象有三个属性，例如： { port: 12346, family: 'IPv4', address: '127.0.0.1' }。
- socket.destroy([exception])：确保在该 socket 上不再有 I/O 活动。仅在出现错误的时候才需要（如解析错误等）。如果制定了 exception，则将会触发一个 'error' 事件，任何监听器都将接收到 exception 作为一个参数。
- ``socket.end([data][, encoding][, callback])``：半关闭 socket。 例如发送一个 FIN 包。 服务端仍可以发送数据。如果指定了 `data`，则相当于调用 `socket.write(data, encoding)` 之后再调用 `socket.end()`。
- socket.setEncoding([encoding])：设置作为可读流（Readable Stream）的编码。
- socket.setTimeout(timeout[, callback])：当 socket 在 timeout 毫秒不活动之后将其设置为超时状态。默认 net.Socket 没有超时。当一个闲置的超时被触发，socket 将会收到一个 'timeout' 事件，但连接不会被断开。用户必须手动调用 socket.end() 或 socket.destroy() 来断开连接。
- ``socket.write(data[, encoding][, callback])``：在 socket 上发送数据。第二个参数制定了字符串的编码 - 默认是 UTF8 编码。如果全部数据都成功刷新到内核的缓冲则返回 true。如果全部或部分数据在用户内中排队，则返回 false。当缓冲再次空闲的时候将触发 'drain' 事件。当数据最终都被写出之后，可选的 callback 参数将会被执行 - 可能不会立即执行。
- 另外，由于TCP套接字是可读可写的Stream对象，可以利用``pipe()``方法巧妙地实现管道操作。

## 服务端和客户端使用TCP socket进行通信的demo

### server.js

```js
const net = require('net');
const server = net.createServer((socket) => {
  // 'connection' 监听器。
  console.log('客户端已连接');
  socket.on('end', () => {
    console.log('客户端已断开连接');
  });
  socket.write('你好\r\n');
  socket.pipe(socket);
});
server.on('error', (err) => {
  throw err;
});
server.listen(8124, () => {
  console.log('服务器已启动');
});
```

### client.js

```js
const net = require('net');
const clientSocket = net.createConnection({ port: 8124 }, () => {
  //'connect' listener
  console.log('connected to server!');
  clientSocket.write('world!\r\n');
});
clientSocket.on('data', (data) => {
  console.log(data.toString());
  clientSocket.end();
});
clientSocket.on('end', () => {
  console.log('disconnected from server');
});
```

