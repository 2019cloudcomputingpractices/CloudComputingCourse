# 本周具体工作计划
+ 制作windows7或者centos7或者ubuntu的镜像，格式为qcow2
+ 利用openstack上传镜像
+ 能够成功创建、开启实例

# 本周主要工作内容
+ 制作镜像：先下载要制作镜像的iso文件，启动系统
+ 在镜像中添加一个文件，文件内容写入branch名称，保存
+ 用命令行或dashboard创建镜像
+ 查看镜像的信息、服务
+ 创建该镜像的实例
+ 实例能够ping通外网
+ 尝试用xshell或者桌面远程连接实例（安全组）
+ 开启实例后能够打开之前创建的文件

## 已完成工作
效果图如下：
在vm中创建文件：
![](https://raw.githubusercontent.com/2019cloudcomputingpractices/CloudComputingCourse/16340147-%E5%88%98%E6%81%92%E4%BC%9F/task3/image/6.png)
映像创建成功：
![](https://raw.githubusercontent.com/2019cloudcomputingpractices/CloudComputingCourse/16340147-%E5%88%98%E6%81%92%E4%BC%9F/task3/image/4.png)
创建实例成功：
![](https://raw.githubusercontent.com/2019cloudcomputingpractices/CloudComputingCourse/16340147-%E5%88%98%E6%81%92%E4%BC%9F/task3/image/3.png)
实例驱动安装完成：
![](https://raw.githubusercontent.com/2019cloudcomputingpractices/CloudComputingCourse/16340147-%E5%88%98%E6%81%92%E4%BC%9F/task3/image/1.png)
实例中有之前创建的文件：
![](https://raw.githubusercontent.com/2019cloudcomputingpractices/CloudComputingCourse/16340147-%E5%88%98%E6%81%92%E4%BC%9F/task3/image/2.png)
实例成功ping通外网：
![](https://raw.githubusercontent.com/2019cloudcomputingpractices/CloudComputingCourse/16340147-%E5%88%98%E6%81%92%E4%BC%9F/task3/image/5.png)
远程桌面连接成功：
![](https://raw.githubusercontent.com/2019cloudcomputingpractices/CloudComputingCourse/16340147-%E5%88%98%E6%81%92%E4%BC%9F/task3/image/7.png)
可以看到已经满足了实验要求，可以远程连接win7的桌面了，并且之前在vm中的文件也依然存在

### qcow2,iso,img的区别
+ ISO映像是一种光盘的存档文件，是磁盘映像的类型之一，数据由一张光盘的每个扇区组成，这包括光盘的文件系统。[1]ISO映像文件通常采用文件扩展名.iso。名称ISO取自用于CD-ROM介质的ISO 9660文件系统，但ISO映像也可包含DVD和蓝光光盘使用的UDF（ISO/IEC 13346）文件系统。

+ IMG是一种文件压缩格式（archive format），主要是为了创建磁盘的映像文件（disk image），它可以用来压缩整个磁盘（通常指软磁盘，Floppy Disk或Diskette）或整片光盘的内容，使用".IMG"这个扩展名的文件就是利用这种文件格式来创建的。
.IMG这个文件格式可视为.ISO格式的一种超集合。由于.ISO只能压缩使用ISO9660和UDF这两种文件系统的存储介质，意即.ISO只能拿来压缩CD或DVD，因此才发展出了.IMG，它是以.ISO格式为基础另外新增可压缩使用其它文件系统的存储介质的能力，.IMG可向后兼容于.ISO，如果是拿来压缩CD或DVD，则使用.IMG和.ISO这两种格式所压缩出来的内容是一样的。

+ qcow2镜像格式是QEMU模拟器支持的一种磁盘镜像。它也是可以用一个文件的形式来表示一块固定大小的块设备磁盘。其只针对虚拟化，在本次实验中我们就用iso映像文件创建了qcow2类型的镜像。

### 为什么要自己制作镜像
镜像可以作为一个系统的一个状态、文件等信息的完整记录，只要制作好了镜像，就可以很轻松的还原某一个环境，比如一些运行环境等等，而不用每次都从头开始安装，然后再进行一步步的配置，比如这次的实验我们在镜像中添加了一个文件，这个文件对于任何的实例就都是默认存在的，一些运行环境同理，总之镜像可以很快速的给用户提供一些初始的软件，运行环境。

### 镜像制作到启动的步骤总结
其主要分为以下几个步骤
+ 上传磁盘映像，如iso,img等格式
+ 利用上传的映像创建虚拟磁盘映像，比如raw,qcow2等
+ 创建vm，安装系统，然后对vm进行需要的个性化环境配置。
+ 将 qcow2 文件上传到 openstack
+ 在openstack中利用qcow2映像创建实例
+ 启动实例，至此启动完成，可以开始使用

### 跟镜像相关的openstack的一些命令
创建映像命令：
```
openstack image create
    [--id <id>]
    [--store <store>]
    [--container-format <container-format>]
    [--disk-format <disk-format>]
    [--size <size>]
    [--min-disk <disk-gb>]
    [--min-ram <ram-mb>]
    [--location <image-url>]
    [--copy-from <image-url>]
    [--file <file> | --volume <volume>]
    [--force]
    [--checksum <checksum>]
    [--protected | --unprotected]
    [--public | --private | --community | --shared]
    [--property <key=value> [...] ]
    [--tag <tag> [...] ]
    [--project <project>]
    [--project-domain <project-domain>]
    <image-name>
```
删除映像命令：
```
openstack image delete
  <image>
```
列出映像命令：
```
openstack image list
    [--public | --private | --community | --shared]
    [--property <key=value>]
    [--name <name>]
    [--status <status>]
    [--member-status <member-status>]
    [--tag <tag>]
    [--long]
    [--sort <key>[:<direction>]]
    [--limit <num-images>]
    [--marker <image>]
```
保存映像命令：
```
openstack image save
    --file <filename>
    <image>
```
设置映像属性命令：
```
openstack image set
    [--name <name>]
    [--min-disk <disk-gb>]
    [--min-ram <ram-mb>]
    [--container-format <container-format>]
    [--disk-format <disk-format>]
    [--size <size>]
    [--protected | --unprotected]
    [--public | --private | --community | --shared]
    [--store <store>]
    [--location <image-url>]
    [--copy-from <image-url>]
    [--file <file>]
    [--volume <volume>]
    [--force]
    [--checksum <checksum>]
    [--stdin]
    [--property <key=value> [...] ]
    [--tag <tag> [...] ]
    [--architecture <architecture>]
    [--instance-id <instance-id>]
    [--kernel-id <kernel-id>]
    [--os-distro <os-distro>]
    [--os-version <os-version>]
    [--ramdisk-id <ramdisk-id>]
    [--deactivate | --activate]
    [--project <project>]
    [--project-domain <project-domain>]
    [--accept | --reject | --pending]
    <image>
```
显示映像详情命令：
```
openstack image show
    [--human-readable]
    <image>
```
## 未完成工作
好像没有
## 问题与困难
这次实验总体来说还是很顺利的，主要遇到了以下两个问题：

（1）在使用VNC Viewer的时候，鼠标不知道为啥总是不同步，在openstack的console里面也会出现这个问题，我一开始尝试设置虚拟机中的鼠标灵敏度，后面只做到了鼠标移动速度相同，但还是没有做到鼠标位置同步，后面我使用远程桌面连接的时候把持久位图缓存关闭后，在远程桌面上的操作就完全同步了，原因依然不是很清楚，好像是和虚拟机的配置有关系。
（2）我在分配完floating ip后去ping上周的baidu地址，发现一直ping不通，后面一直在找网络的问题但是一直没有找到。后面用nslookup命令后才发现百度的ip地址和上周的已经完全不一样了，后面Ping了新的ip地址就成功ping通了。
## 建议与意见
这次好像没有，TA写的教程很贴心，很实用，感谢TA大大